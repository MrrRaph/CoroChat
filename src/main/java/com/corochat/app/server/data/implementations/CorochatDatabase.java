package com.corochat.app.server.data.implementations;

import com.corochat.app.server.data.AbstractCorochatDatabase;
import com.corochat.app.server.data.repositories.UserRepository;
import com.corochat.app.server.data.daos.MessageDao;
import com.corochat.app.server.data.daos.UserDao;
import com.corochat.app.server.data.names.DataMessageName;
import com.corochat.app.server.data.names.DataUserName;
import com.corochat.app.server.utils.logger.Logger;
import com.corochat.app.server.utils.logger.LoggerFactory;
import com.corochat.app.server.utils.logger.level.Level;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * <h1>The CorochatDatabase object</h1>
 * <p>
 *     This class extends AbstractCorochatDatabase
 *     in order to be an implementation of it.
 * </p>
 * //TODO Include diagram of UserModel
 *
 * @author Raphael Dray
 * @version 0.0.4
 * @since 0.0.2
 * @see AbstractCorochatDatabase
 * @see UserDao
 * @see MessageDao
 * @see Connection
 */
public final class CorochatDatabase extends AbstractCorochatDatabase {
    private static final Logger logger = LoggerFactory.getLogger(CorochatDatabase.class.getSimpleName());

    private volatile UserDao userDao;
    private volatile MessageDao messageDao;
    /**
     * Unique instance of CorochatDatabase
     */
    private static volatile CorochatDatabase INSTANCE = null;

    private final AbstractCorochatDatabase database;
    private final Connection connection;

    /**
     * This constructor initialize its attributes.
     * It fetches the instance of an AbstractCorochatDatabase
     * and give himself as an implementation of it.
     * It creates tables and indexes for the SQL tables.
     */
    private CorochatDatabase() {
        this.database = AbstractCorochatDatabase.getInstance(this);
        this.connection = databaseConnection;
        createAllTables();
        createUniqueIndexEmail();
        createUniqueIndexPseudo();
        logger.log("Creating all tables and their indexes", Level.INFO);
    }

    /**
     * Singleton design pattern to retrieve the unique instance of the CorochatDatabase
     * @return UserRepository - The unique instance of the corochat database
     */
    public static CorochatDatabase getInstance() {
        if (INSTANCE == null)
            synchronized (UserRepository.class) {
                if (INSTANCE == null)
                    INSTANCE = new CorochatDatabase();
            }
        return INSTANCE;
    }

    /**
     * Creating an instance of UserDao
     * @return UserDao - Unique instance of user DAO
     */
    @Override
    public UserDao userDao() {
        if (this.userDao != null)
            return this.userDao;
        else synchronized (this) {
            if (this.userDao == null)
                this.userDao = new UserDaoImpl(this);
            return this.userDao;
        }
    }

    /**
     * Creating an instance of MessageDao
     * @return MessageDao - Unique instance of message DAO
     */
    @Override
    public MessageDao messageDao() {
        if (this.messageDao != null)
            return this.messageDao;
        else synchronized (this) {
            if (this.messageDao == null)
                this.messageDao = new MessageDaoImpl(this);
            return this.messageDao;
        }
    }

    /**
     * Getter of the database connection
     * @return Connection - The database connection
     */
    public Connection getConnection() {
        return this.connection;
    }

    /**
     * Create the user table with SQL and PL/SQL
     */
    private void createUserTable() {
        final String createUserTableSQL = "CREATE TABLE " + DataUserName.TABLE_NAME + " (" +
                           DataUserName.COL_ID + " INTEGER GENERATED BY DEFAULT ON NULL AS IDENTITY, " + DataUserName.COL_FIRST_NAME + " VARCHAR(255), " +
                           DataUserName.COL_LAST_NAME + " VARCHAR(255), " + DataUserName.COL_PSEUDO + " VARCHAR(255), " +
                           DataUserName.COL_EMAIL + " VARCHAR(255), " + DataUserName.COL_HASHED_PASSWORD + " VARCHAR(255), " +
                           DataUserName.COL_ACTIVE + " INTEGER NOT NULL, " +
                           "CONSTRAINT pk_user PRIMARY KEY(" + DataUserName.COL_ID + "))";

        final String plsql = "DECLARE v_count NUMBER(1);\nBEGIN\n SELECT count(1) " +
                             "INTO v_count " +
                             "FROM dba_tables " +
                             "WHERE table_name = '" + DataUserName.TABLE_NAME.toUpperCase() + "';\n" +
                             "IF v_count = 0 THEN\n" +
                             " EXECUTE IMMEDIATE '" + createUserTableSQL + "';\n" +
                             "END IF;\n" +
                             "END;";
        try {
            final Statement statement = this.connection.createStatement();
            statement.executeUpdate(plsql);
            statement.close();
        } catch (SQLException e) {
            logger.log(e.getMessage(), Level.ERROR);
        }
    }

    /**
     * Create the message table with SQL and PL/SQL
     */
    private void createMessageTable() {
        final String createMessageTableSQL = "CREATE TABLE " + DataMessageName.TABLE_NAME + " (" +
                DataMessageName.COL_ID + " INTEGER GENERATED BY DEFAULT ON NULL AS IDENTITY, " + DataMessageName.COL_MESSAGE + " VARCHAR(255), " +
                DataMessageName.COL_USER_PSEUDO + " NVARCHAR2(255), " + DataMessageName.COL_DATE + " TIMESTAMP, " +
                "CONSTRAINT pk_message PRIMARY KEY(" + DataMessageName.COL_ID + "))";

        final String plsql = "DECLARE v_count NUMBER(1);\nBEGIN\n SELECT count(1) " +
                "INTO v_count " +
                "FROM dba_tables " +
                "WHERE table_name = '" + DataMessageName.TABLE_NAME.toUpperCase() + "';\n" +
                "IF v_count = 0 THEN\n" +
                " EXECUTE IMMEDIATE '" + createMessageTableSQL + "';\n" +
                "END IF;\n" +
                "END;";
        try {
            final Statement statement = this.connection.createStatement();
            statement.executeUpdate(plsql);
            statement.close();
        } catch (SQLException e) {
            logger.log(e.getMessage(), Level.ERROR);
        }
    }

    /**
     * Create all tables
     */
    private void createAllTables(){
        createUserTable();
        createMessageTable();
        logger.log("Tables created successfully", Level.INFO);
    }

    /**
     * Create unique index for email
     */
    private void createUniqueIndexEmail() {
        final String createUniqueIndex = "DECLARE " +
                "already_exists exception; " +
                "columns_indexed exception; " +
                "pragma exception_init(already_exists, -955); " +
                "pragma exception_init(columns_indexed, -1408); " +
                "BEGIN " +
                "EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX UNIDX_USER_EMAIL " +
                "ON " + DataUserName.TABLE_NAME +
                " (" + DataUserName.COL_EMAIL + " ASC)'; " +
                "EXCEPTION WHEN already_exists OR columns_indexed " +
                "THEN NULL;" +
                "END;";
        try {
            final Statement statement = this.connection.createStatement();
            statement.executeUpdate(createUniqueIndex);
            logger.log("Unique index created on " + DataUserName.TABLE_NAME, Level.INFO);
            statement.close();
        } catch (SQLException e) {
            logger.log(e.getMessage(), Level.ERROR);
        }
    }

    /**
     * Create unique index for pseudo
     */
    private void createUniqueIndexPseudo() {
        final String createUniqueIndex = "DECLARE " +
                "already_exists exception; " +
                "columns_indexed exception; " +
                "pragma exception_init(already_exists, -955); " +
                "pragma exception_init(columns_indexed, -1408); " +
                "BEGIN " +
                "EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX UNIDX_USER_PSEUDO " +
                "ON " + DataUserName.TABLE_NAME +
                " (" + DataUserName.COL_PSEUDO + " ASC)'; " +
                "EXCEPTION WHEN already_exists OR columns_indexed THEN " +
                "NULL;" +
                "END;";
        try {
            final Statement statement = this.connection.createStatement();
            statement.executeUpdate(createUniqueIndex);
            logger.log("Unique index created on " + DataUserName.TABLE_NAME, Level.INFO);
            statement.close();
        } catch (SQLException e) {
            logger.log(e.getMessage(), Level.ERROR);
        }
    }
}
